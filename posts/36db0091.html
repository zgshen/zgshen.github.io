<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>从 Java8 到 Java11 再到 Java17 的新特性(1) - zguishen&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=技术,Java,NewFeatures>
  
    <meta name="description" content="zgshen,zguishen,甘甘">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="zguishen&#39;s blog" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

  <!-- <script data-ad-client="ca-pub-2187290877628564" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js"></script>
  <script>
    pangu.spacingElementByClassName('post');
    document.addEventListener('DOMContentLoaded', () => {
      // listen to any DOM change and automatically perform spacing via MutationObserver()
      pangu.autoSpacingPage();
    });
  </script>
<meta name="generator" content="Hexo 6.2.0"></head>
  <body>
    <div class="container">
      <article class="post">
  <div class="post-title">
    <h1 class="article-title">从 Java8 到 Java11 再到 Java17 的新特性(1)</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2021-09-19</span>
  </div>
  <div class="post-content">
    
	<div id="toc" class="toc-article">
	  <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">1. Lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">2. 接口默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Optional-%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">3. Optional 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Stream-%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">4. Stream 流处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Base64-%E5%B7%A5%E5%85%B7"><span class="toc-number">5.</span> <span class="toc-text">4.  Base64 工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7"><span class="toc-number">6.</span> <span class="toc-text">5.  新的日期和时间工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-CompletableFuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">6. CompletableFuture 异步编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">7. 参考</span></a></li></ol>
    </div>
	
	
    <p>从 JDK8 之后，Java 的更新策略改为以时间驱动的方式，每六个月发布一个新的Java版本，每三年发表一个长期支持版本。一般如果要对旧 JDK 进行升级，都会选择长期支持版，JDK11 和最近更新的 JDK17 是长期支持版本。但是由于商业项目更看重稳定性，更新 JDK 带来的收益不大，大多数人不愿意踩坑去更新 JDK。因此，很多人都只是从新闻了解到新 JDK 的新特性，平常开发没有接触到，甚至有些在用 JDK8 的人连 JDK8 的新特性都用不利索或者直接就不知道。其实许多新特性是可以简化我们的开发，能让我们以更优雅的方式实现功能。接下来我将分三篇文章分别简单介绍 JDK8、JDK9-JDk11 和 JDK12-JDK17 在编码方面的一些新功能，至于虚拟机的改进和其他部门这里暂不做讨论。</p>
<p>先从 Java8 开始说起，看看部分常用的新特性。<br>本文源码地址：<a target="_blank" rel="noopener" href="https://github.com/zgshen/code-note/tree/master/src/com/jdk/java8">code-note</a></p>
<h3 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h3><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），让匿名内部类的写法更简便。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LambdaTest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LambdaTest</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//use param str to do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">interfaceTest</span><span class="params">(SingleFncInterface singleFunInterface)</span> &#123;</span><br><span class="line">        singleFunInterface.doSomething(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleMenthod</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;simple method. str is:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMenthod</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static menthod. str is:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单函数接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SingleFncInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;default method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 <code>SingleFncInterface</code> 是一个典型的函数式接口，只包含一个抽象方法，可以加上 <code>@FunctionalInterface</code> 注解标记，限制只允许定义一个抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lambda 本质就是单函数接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singleFunTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//作为参数的形式</span></span><br><span class="line">    LambdaTest.interfaceTest((String str) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;single function interface. param:&quot;</span> + str);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SingleFncInterface s = (String str) -&gt; System.out.println(str);</span></span><br><span class="line">	<span class="type">SingleFncInterface</span> <span class="variable">s</span> <span class="operator">=</span> str -&gt; System.out.println(str);</span><br><span class="line">    s.doSomething(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简化形式，方法引用</span></span><br><span class="line">    <span class="comment">//LambdaTest.interfaceTest(item -&gt; System.out.println(item));</span></span><br><span class="line">    LambdaTest.interfaceTest(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 lambda 表达式的语法格式是如：(parameters) -&gt; expression&#x2F;statements，特殊的还有更加简化的方法引用方式。</p>
<p>方法引用可分为三种，静态、实例和构造引用，使用例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//静态引用。意思就是用 String 的 valof() 方法来实现 Function 接口的 apply 方法</span></span><br><span class="line">    Function&lt;Integer, String&gt; fun = String::valueOf;</span><br><span class="line">    <span class="type">String</span> <span class="variable">apply</span> <span class="operator">=</span> fun.apply(<span class="number">100</span>);</span><br><span class="line">    System.out.println(apply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态引用</span></span><br><span class="line">    <span class="type">SingleFncInterface</span> <span class="variable">sfi1</span> <span class="operator">=</span> LambdaTest::staticMenthod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例引用</span></span><br><span class="line">    <span class="type">LambdaTest</span> <span class="variable">lambdaTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTest</span>();</span><br><span class="line">    <span class="type">SingleFncInterface</span> <span class="variable">sfi2</span> <span class="operator">=</span> lambdaTest::simpleMenthod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造引用，带参数</span></span><br><span class="line">    <span class="type">SingleFncInterface</span> <span class="variable">sfi3</span> <span class="operator">=</span> LambdaTest::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造引用，不带参数</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> LambdaTest::<span class="keyword">new</span>;</span><br><span class="line">    <span class="comment">//runnable.run();//单函数 Runnable 接口 run 方法由 LambdaTest 构造实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据输入和返回参数的不同，JDK 中提供了四种类型的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四种类型函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Function&lt;T, R&gt;</span></span><br><span class="line"><span class="comment">     * 调用方法 R apply(T t);</span></span><br><span class="line"><span class="comment">     * T：入参类型，R：出参类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Function&lt;Integer, Integer&gt; function = n -&gt; n*n;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">apply</span> <span class="operator">=</span> function.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(apply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Consumer&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * 调用方法：void accept(T t);</span></span><br><span class="line"><span class="comment">     * T：入参类型；没有出参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">    consumer.accept(<span class="string">&quot;output msg.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Supplier&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * 调用方法：T get();</span></span><br><span class="line"><span class="comment">     * T：出参类型；没有入参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Supplier&lt;Integer&gt; supplier = () -&gt; <span class="number">10</span>*<span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">    System.out.println(integer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Predicate&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * 调用方法：boolean test(T t);</span></span><br><span class="line"><span class="comment">     * T：入参类型；出参类型是Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Predicate&lt;Integer&gt; predicate = num -&gt; num&gt;<span class="number">10</span>;<span class="comment">//是否大于10</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> predicate.test(<span class="number">20</span>);</span><br><span class="line">    System.out.println(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-接口默认方法"><a href="#2-接口默认方法" class="headerlink" title="2. 接口默认方法"></a>2. 接口默认方法</h3><p>Java8 允许在接口中添加一个或者多个默认方法，在 <code>SingleFncInterface</code> 接口中 <code>print()</code> 就是一个默认方法。增加默认方法是为了给接口添加新方法的同时不影响已有的实现，不需要修改全部实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SingleFncInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;default method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Optional-类"><a href="#3-Optional-类" class="headerlink" title="3. Optional 类"></a>3. Optional 类</h3><p>在 Java8 之前，空指针异常是编码时最需要注意的异常，我们往往都需要手动对变量进行 null 值判断，对可能的空指针异常进行捕获处理。Java8 提供的 Optional 类可以以比较优雅的方式进行空值判断，解决空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="keyword">private</span> Insurance insurance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        insurance = <span class="keyword">new</span> <span class="title class_">Insurance</span>(<span class="string">&quot;Tesla&quot;</span>);</span><br><span class="line">        car = <span class="keyword">new</span> <span class="title class_">Car</span>(Optional.of(insurance));</span><br><span class="line">        person = <span class="keyword">new</span> <span class="title class_">Person</span>(Optional.of(car));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//允许传递为 null 的参数</span></span><br><span class="line">        Optional&lt;Insurance&gt; insurance = Optional.ofNullable(<span class="built_in">this</span>.insurance);</span><br><span class="line">        Optional&lt;String&gt; s = insurance.map(insurance1 -&gt; insurance1.getName());</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        Optional&lt;Person&gt; person = Optional.of(<span class="built_in">this</span>.person);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> person.flatMap(Person::getCar)</span><br><span class="line">                .flatMap(Car::getInsurance)<span class="comment">//拿到封装的 Optional&lt;Car&gt;</span></span><br><span class="line">                .map(Insurance::getName)<span class="comment">//直接拿到值</span></span><br><span class="line">                .orElse(<span class="string">&quot;ubknow&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        Optional&lt;Car&gt; c = Optional.empty();</span><br><span class="line">        Optional&lt;String&gt; s = c.flatMap(Car::getInsurance)</span><br><span class="line">                .map(Insurance::getName);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">String</span> <span class="variable">unknow</span> <span class="operator">=</span> s.orElse(<span class="string">&quot;unknow&quot;</span>);</span><br><span class="line">        System.out.println(unknow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Car&gt; car;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Optional&lt;Car&gt; car)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Car&gt; <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Insurance&gt; insurance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Optional&lt;Insurance&gt; insurance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.insurance = insurance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Insurance&gt; <span class="title function_">getInsurance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Insurance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Insurance</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Insurance&gt; insurance = Optional.of(<span class="built_in">this</span>.insurance)</span><br><span class="line"><span class="comment">// this.insurance 为 null 返回 Optional.empty</span></span><br><span class="line">Optional&lt;Insurance&gt; insurance = Optional.ofNullable(<span class="built_in">this</span>.insurance)</span><br></pre></td></tr></table></figure>
<p>简单来说，如果想得到一个非 null 值的 Optional 使用 <code>Optional.of</code>，允许 null 值的话使用 <code>Optional.ofNullable</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> person.flatMap(Person::getCar)</span><br><span class="line">                .flatMap(Car::getInsurance)</span><br><span class="line">                .map(Insurance::getName)</span><br><span class="line">                .orElse(<span class="string">&quot;unknown&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>对于返回一个 <code>Optional</code> 结果集需要使用 <code>flatMap</code>，比如 <code>Person::getCar</code> 方法和 <code>Car::getInsurance</code>，只要单一转换的使用 <code>map</code>，例如 <code>Insurance::getName</code>，如果是 empty 返回 orElse 的内容。</p>
<h3 id="4-Stream-流处理"><a href="#4-Stream-流处理" class="headerlink" title="4. Stream 流处理"></a>4. Stream 流处理</h3><p>流 Stream 通过声明的方式来处理数据，可以在管道的节点上对数据进行排序、聚合、筛选、去重和截取等等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.IntSummaryStatistics;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Fruit&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;apple&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;banana&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outputTest</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        integers.forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        integers.stream().forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//并行流底层使用Fork/Join框架实现，异步处理，输出不一定是12345</span></span><br><span class="line">        integers.parallelStream().forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mapTest</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//映射每个元素操作，生成新的结果</span></span><br><span class="line">        List&lt;Integer&gt; collect = integers.stream().map(n -&gt; n * n).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; fruitList = fruits.stream().map(obj -&gt; obj.name=<span class="string">&quot;I like &quot;</span>.concat(obj.name)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(fruitList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序、过滤、限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filterTest</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">5</span>);</span><br><span class="line">        List&lt;Integer&gt; collect = integers.stream()</span><br><span class="line">                <span class="comment">//.sorted()//排序</span></span><br><span class="line">                .sorted((x, y) -&gt; y - x)</span><br><span class="line">                .distinct()<span class="comment">//去重</span></span><br><span class="line">                .filter(n -&gt; n &lt; <span class="number">6</span>)<span class="comment">//小于6的数</span></span><br><span class="line">                .limit(<span class="number">3</span>)<span class="comment">//只截取3个元素</span></span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 聚合和统计</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTest</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> strings.stream().collect(Collectors.joining(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fruit</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Base64-工具"><a href="#4-Base64-工具" class="headerlink" title="4.  Base64 工具"></a>4.  Base64 工具</h3><p>Java 8 内置了 Base64 编码的编码器和解码器，支持三种编解码方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base64Example</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">//基本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(<span class="string">&quot;base64test&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(Base64.getDecoder().decode(s1), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//URL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> Base64.getUrlEncoder().encodeToString(<span class="string">&quot;base64test&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Mime</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> Base64.getMimeEncoder().encodeToString(<span class="string">&quot;base64test&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-新的日期和时间工具"><a href="#5-新的日期和时间工具" class="headerlink" title="5.  新的日期和时间工具"></a>5.  新的日期和时间工具</h3><p>在过去，Java 处理日期和时间我们一般是用 <code>java.util.Date</code>、<code>java.util.Calendar</code>  配合 <code>java.text.SimpleDateFormat</code> 来使用的，缺点是易用性差，线程不安全，不支持时区，新的日期和时间 API  解决了这些问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2021</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> localDateTime.format(formatter);</span><br><span class="line">        System.out.println(format);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-01-01 12:00:00&quot;</span>, formatter);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-CompletableFuture-异步编程"><a href="#6-CompletableFuture-异步编程" class="headerlink" title="6. CompletableFuture 异步编程"></a>6. CompletableFuture 异步编程</h3><p>在 Java8 之前 Future 接口提供了异步执行任务的能力，但对于结果的获取只能通过阻塞或者轮询的方式。为了增强异步编程的功能，Java8 添加了 CompletableFuture 类，CompletableFuture 类实现了 CompletionStage 和 Future 接口，默认使用 ForkJoinPool.commonPool() 线程池。</p>
<p>commonPool 是当前 JVM（进程） 上的所有 CompletableFuture、并行 Stream 共享的，commonPool 的目标场景是非阻塞的 CPU 密集型任务，其线程数默认为 CPU 数量减1，所以对于我们用 java 常做的 IO 密集型任务，默认线程池是远远不够使用的；在双核及以下机器上，默认线程池又会退化为为每个任务创建一个线程，相当于没有线程池。所以使用 CompletableFuture 时要根据业务决定是否需要自定义线程池。</p>
<p>在 CompletableFuture 中带有 Async 的都是异步方法，get 方法是同步的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">futureTest</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//单纯地返回一个值</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接进行运算并返回</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2500L</span>);</span><br><span class="line">            <span class="comment">//Thread.sleep(1000L);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//是否执行完毕</span></span><br><span class="line">    System.out.println(supplyAsync.isDone());</span><br><span class="line">    <span class="comment">//立刻返回执行结果或异常，否则返回指定值</span></span><br><span class="line">    System.out.println(supplyAsync.getNow(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//设置超时</span></span><br><span class="line">    System.out.println(supplyAsync.get(<span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于多步骤的处理用 thenApply </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">//多步骤处理，一个步骤处理完把结果返回给下一步继续处理，同步 thenApply，异步 thenApplyAsync</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.completedFuture(<span class="number">1</span>)</span><br><span class="line">            .thenApply(i -&gt; i + <span class="number">2</span>)</span><br><span class="line">            .thenApplyAsync(i -&gt; i + <span class="number">3</span>)</span><br><span class="line">            <span class="comment">//计算完毕后的处理，不影响 get 返回值</span></span><br><span class="line">            .whenCompleteAsync((result, exception) -&gt; &#123;</span><br><span class="line">                result *= <span class="number">10</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;calculate result:&quot;</span> + result);</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合方法用 thenCompose</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thenComposeExample</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">original</span> <span class="operator">=</span> <span class="string">&quot;Message&quot;</span>;</span><br><span class="line">    <span class="comment">//将字符串转换大写，得到结果再转换小写，再组合起来</span></span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">cf</span> <span class="operator">=</span> CompletableFuture.completedFuture(original)</span><br><span class="line">            .thenApply(s -&gt; s.toUpperCase())</span><br><span class="line">            .thenCompose(upper -&gt; CompletableFuture.completedFuture(original)</span><br><span class="line">                    .thenApply(s -&gt; s.toLowerCase())</span><br><span class="line">                    .thenApply(s -&gt; upper + s));</span><br><span class="line">    System.out.println(cf.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待多个任务一起执行完毕再进行处理可以使用 allOf 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">allof</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    List&lt;Integer&gt; integers = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    List&lt;CompletableFuture&lt;Integer&gt;&gt; futureList = integers.stream()</span><br><span class="line">                    .map(item -&gt; CompletableFuture.completedFuture(item).thenApplyAsync(num -&gt; num * num))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    CompletableFuture&lt;Void&gt; allof = CompletableFuture</span><br><span class="line">            .allOf(futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[futureList.size()]))</span><br><span class="line">            .whenCompleteAsync((result, exception) -&gt; &#123;</span><br><span class="line">                futureList.forEach(cf -&gt; &#123;</span><br><span class="line">                    System.out.println(cf.getNow(<span class="number">0</span>));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//handle 住看输出结果，因为是上面都用异步的，这里不等很可能看不到输出</span></span><br><span class="line">    allof.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h3><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">Java Platform SE 8</a></li>
<li>[2] <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java8-new-features.html">Java 8  新特性 | 菜鸟教程</a></li>
<li>[3] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c9dc192fa63">CompletableFuture避坑1——需要自定义线程池</a></li>
</ul>

  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/NewFeatures/" rel="tag">NewFeatures</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>
    

    <a href="#top" class="top">返回顶部</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    zguishen
  </span>
   / Documentation licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
  </span>
</footer>
    </div>
  </body>
</html>