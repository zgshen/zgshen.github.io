<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>【转载】Why Java&#39;s Records Are Better Than Lombok&#39;s @Data and Kotlin&#39;s Data Classes - zguishen&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=技术,Java>
  
    <meta name="description" content="zgshen,zguishen,甘甘">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="zguishen&#39;s blog" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

  <!-- <script data-ad-client="ca-pub-2187290877628564" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js"></script>
  <script>
    pangu.spacingElementByClassName('post');
    document.addEventListener('DOMContentLoaded', () => {
      // listen to any DOM change and automatically perform spacing via MutationObserver()
      pangu.autoSpacingPage();
    });
  </script>
<meta name="generator" content="Hexo 6.2.0"></head>
  <body>
    <div class="container">
      <article class="post">
  <div class="post-title">
    <h1 class="article-title">【转载】Why Java&#39;s Records Are Better Than Lombok&#39;s @Data and Kotlin&#39;s Data Classes</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2021-09-25</span>
  </div>
  <div class="post-content">
    
	<div id="toc" class="toc-article">
	  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Record-Semantics"><span class="toc-number">1.</span> <span class="toc-text">Record Semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transparency-amp-Restrictions"><span class="toc-number">1.1.</span> <span class="toc-text">Transparency &amp; Restrictions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-sorry"><span class="toc-number">1.2.</span> <span class="toc-text">Math (sorry)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consequences"><span class="toc-number">1.3.</span> <span class="toc-text">Consequences</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Records-Are-Better"><span class="toc-number">2.</span> <span class="toc-text">Why Records Are Better*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Destructuring-Patterns"><span class="toc-number">2.1.</span> <span class="toc-text">Destructuring Patterns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with-blocks"><span class="toc-number">2.2.</span> <span class="toc-text">with blocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serialization"><span class="toc-number">2.3.</span> <span class="toc-text">Serialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Also-The-Boilerplate"><span class="toc-number">2.4.</span> <span class="toc-text">Also, The Boilerplate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Records-Are-Worse"><span class="toc-number">3.</span> <span class="toc-text">Why Records Are Worse*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-Lombok-39-s-Data-x2F-Value-Is-Better"><span class="toc-number">3.1.</span> <span class="toc-text">Why Lombok&#39;s @Data&#x2F;@Value Is Better*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-Kotlin-39-s-Data-Classes-Are-Better"><span class="toc-number">3.2.</span> <span class="toc-text">Why Kotlin&#39;s Data Classes Are Better*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflection"><span class="toc-number">4.</span> <span class="toc-text">Reflection</span></a></li></ol>
    </div>
	
	
    <p>原文链接：<a target="_blank" rel="noopener" href="https://nipafx.dev/java-record-semantics/">https://nipafx.dev/java-record-semantics/</a></p>
<p>While all three remove boilerplate, the similarities don&#39;t go much further. Records have stronger semantics with important downstream benefits, which makes them better. (not always; depends on circumstances; excuse the clickbait)</p>
<p><img src="/../images/202109/record-semantics.webp"></p>
<p>I&#39;m sure by now you&#39;ve all seen the examples of how records turn a full-blown POJO ...</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> low;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Range</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.low = low;</span><br><span class="line">		<span class="built_in">this</span>.high = high;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLow</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHigh</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> high;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> (Range) o;</span><br><span class="line">		<span class="type">return</span> <span class="variable">low</span> <span class="operator">=</span>= range.low &amp;&amp;</span><br><span class="line">				high == range.high;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Objects.hash(low, high);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + low + <span class="string">&quot;; &quot;</span> + high + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>...into a single line of code:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//          these are &quot;components&quot;</span></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Range</span> (<span class="type">int</span> low, <span class="type">int</span> hight) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>Of course Lombok&#39;s @Data or @Value (depending on your needs) could do that for years with a few more lines:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> low;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And if you&#39;re familiar with Kotlin, you know how data classes do the same:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data <span class="keyword">class</span> <span class="title class_">Range</span>(val low: Int, val high: Int)</span><br></pre></td></tr></table></figure>
<p>So these are essentially the same features right? No. No, they&#39;re really not. Because for records, boilerplate reduction is not the purpose, it&#39;s just a (welcome) consequence of their semantics.</p>
<p><em>[These are really not the same features]</em></p>
<p>Unfortunately, this gets easily lost. The boilerplate reduction is obvious and sexy and easy to demonstrate, so it gets a lot of exposure. But the semantics and their benefits don&#39;t. It doesn&#39;t help that <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/language/records.html">the official documentation</a> also takes the boilerplate angle and while <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/395">JEP 395</a> better explains the semantics, due to its scope it&#39;s naturally vague when it comes to describing the downstream benefits. So I thought I&#39;d write them down here.</p>
<p>First semantics, then benefits.</p>
<h2 id="Record-Semantics"><a href="#Record-Semantics" class="headerlink" title="Record Semantics"></a>Record Semantics</h2><p>JEP 395 says:</p>
<p><em>[Records are transparent carriers for immutable data]</em></p>
<blockquote>
<p>[Records] are classes that act as transparent carriers for immutable data.</p>
</blockquote>
<p>So by creating a record you&#39;re telling the compiler, your colleagues, the whole wide world that this type is about data. More precisely, data that&#39;s (shallowly) immutable and transparently accessible. That&#39;s the core semantic - everything else follows from here.</p>
<p>If this semantic doesn&#39;t apply to the type you want to create, then you shouldn&#39;t create a record. If you do it anyways (maybe lured in by the promise of no boilerplate or because you think records are equivalent to <code>@Data</code>&#x2F;<code>@Value</code> or data classes), you&#39;re muddying your design and chances are good that it will come back to bite you. So don&#39;t.</p>
<p>(Sorry for the harsh words, but it needed to be said.)</p>
<h3 id="Transparency-amp-Restrictions"><a href="#Transparency-amp-Restrictions" class="headerlink" title="Transparency &amp; Restrictions"></a>Transparency &amp; Restrictions</h3><p>Let&#39;s have a closer look at transparency. Records even have a motto for that - paraphrasing <a target="_blank" rel="noopener" href="https://cr.openjdk.java.net/~briangoetz/amber/datum.html">a Project Amber design document:</a></p>
<blockquote>
<p>The API for a record models the state, the whole state, and nothing but the state.</p>
</blockquote>
<p>To live up to that, some restrictions are needed:</p>
<ul>
<li>an accessor for each component with the same name and return type that returns exactly the component&#39;s value (or the API doesn&#39;t model the state)</li>
<li>an accessible constructor whose parameter list matches the components (called canonical constructor; or the API doesn&#39;t model the state)</li>
<li>no additional fields (or the API doesn&#39;t model the whole state)</li>
<li>no class inheritance (or the API doesn&#39;t model the whole state because more can be hiding elsewhere)</li>
</ul>
<p>Why, though? Lombok allows additional fields and Kotlin&#39;s data classes, too, as well as private &quot;components&quot; (that&#39;s the record term; Kotlin calls them primary constructor parameters). So why is Java so strict about this? To answer that, we need some math.</p>
<h3 id="Math-sorry"><a href="#Math-sorry" class="headerlink" title="Math (sorry)"></a>Math (sorry)</h3><p>A set is a bunch of elements, e.g. we can say C is the set of all colors { blue, gold, ... } and N the set of all natural numbers { 0, 1, ...}. The finite set { -2147483648, ..., 0, ..., 2147483647} is what we in Java typically call int and if we throw in null we get Integer. Similarly, the infinite set of all possible strings (plus null 🙄) is what we call String.</p>
<p>So, as you can see, types are sets where the set&#39;s values are exactly the values that are legal for that type. That also means that set theory, &quot;the branch of mathematical logic that studies sets&quot; (says Wikipedia), is related to type theory, &quot;the academic study of type systems&quot; (likewise), which language design relies on.</p>
<p><em>[Types are sets]</em></p>
<p>Now let&#39;s do something fancy and build pairs of integers (yes, that fancy): { (0, 0), (0, 1), ... }. This is what a simple and terribly incomplete Java class for that would look like:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> first;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> second;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We could call the corresponding set Pair and that would work. But there&#39;s a bit more insight to be had because we know more about the set&#39;s structure. Specifically, we know that it&#39;s the combination of all ints with all ints. Set theory calls that a product and it&#39;s written as int × int (each type in a product is called an operand).</p>
<p>That&#39;s pretty cool because set theory has all kinds of things to say about applying functions to these products. One aspect of that is how functions that operate on a single operand can be combined to functions that operate on all operands and which properties of the functions (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Injective_function">injective</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bijection">bijective</a>, etc.) remain intact.</p>
<p>For example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// given: bijective function from int to int</span></span><br><span class="line"><span class="type">IntUnaryOperator</span> <span class="variable">increment</span> <span class="operator">=</span></span><br><span class="line">	i -&gt; i == Integer.MAX_VALUE ? Integer.MIN_VALUE : ++i;</span><br><span class="line"><span class="comment">// then: combining two `increment`s yields a bijective function</span></span><br><span class="line"><span class="comment">//       (this requires no additional proof or consideration)</span></span><br><span class="line">UnaryOperator&lt;Pair&gt; incrementPair =</span><br><span class="line">	pair -&gt; <span class="keyword">new</span> <span class="title class_">Pair</span>(</span><br><span class="line">		increment.applyAsInt(pair.first()),</span><br><span class="line">		increment.applyAsInt(pair.second()));</span><br></pre></td></tr></table></figure>

<p>Did you note the accessors Pair::first and Pair::second? They didn&#39;t exist in the class above, so I need to add them. Otherwise I couldn&#39;t apply functions to individual components&#x2F;operands and so I couldn&#39;t really use Pair as a pair of ints. Similarly, but in the other direction, I needed a constructor that takes both ints as arguments so I can reconstitute a pair.</p>
<p>More generally, to apply set theory to a type in the way I alluded to above, all its operands need to be accessible and there must be a way to turn a tuple of operands into an instance. If both is true, type theory calls such a type a product type (and their instances tuples) and there are a few cool things we can do with them.</p>
<p>Actually, records are even better* than tuples. JEP 395 says:</p>
<blockquote>
<p>Records can be thought of as nominal tuples.</p>
</blockquote>
<p>Where nominal means that records are identified by their name and not their structure. That way you can&#39;t mix up two different record types that both model int × int, for example Pair(int first, int second) and Range(int low, int high). Also, we access the record components not by index (not range.get1()) but by name (record.low()).</p>
<p>(Beyond that, a record&#39;s accessors and its canonical constructor form an embedding-projection pair, but I hardly understand that. Definitely too little to explain.)</p>
<h3 id="Consequences"><a href="#Consequences" class="headerlink" title="Consequences"></a>Consequences</h3><p>I want to drive the point home: Records want to be product types (because of the cool things) and for that to work, all their components must be accessible, i.e. there can be no hidden state, and construction from them must be possible. That&#39;s why records are transparent carriers of immutable data.</p>
<p><em>[Records are product types; that&#39;s why they&#39;re transparent]</em></p>
<p>Hence the compiler generates accessors.</p>
<p>Hence we can&#39;t change their names or return type.</p>
<p>Hence we should be very careful with overriding them.</p>
<p>Hence the compiler generates a canonical constructor.</p>
<p>Hence there can be no inheritance.</p>
<h2 id="Why-Records-Are-Better"><a href="#Why-Records-Are-Better" class="headerlink" title="Why Records Are Better*"></a>Why Records Are Better*</h2><p>Most benefits we get from the algebraic structure revolve around the fact that the accessors together with the canonical constructor allow to take apart and recreate record instances in a structured manner without loss of information.</p>
<h3 id="Destructuring-Patterns"><a href="#Destructuring-Patterns" class="headerlink" title="Destructuring Patterns"></a>Destructuring Patterns</h3><p>JEP 405 proposes record and array patterns, which will enhance Java&#39;s pattern matching capabilities. They will allow us to take records and arrays apart and apply further checks to their components:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (range <span class="keyword">instanceof</span> <span class="title function_">Range</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> &amp;&amp; high &lt; low)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Range</span>(high, low);</span><br></pre></td></tr></table></figure>

<p>Thanks to full transparency, we can be sure not to miss hidden state. That means that the difference between range and the returned instance is exactly what you see: low and high are flipped - nothing more.</p>
<h3 id="with-blocks"><a href="#with-blocks" class="headerlink" title="with blocks"></a>with blocks</h3><p>A future version of Java may introduce with blocks that make it very easy to create copies of (usually immutable) instances with some values changed. It could look something like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Range</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// SYNTAX IS MADE UP!</span></span><br><span class="line"><span class="type">Range</span> <span class="variable">newRange</span> <span class="operator">=</span> range with &#123; low = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">// range: [5; 10]</span></span><br><span class="line"><span class="comment">// newRange: [0; 10]</span></span><br></pre></td></tr></table></figure>

<p>The language can derive with expressions precisely because Ranges API is aligned with its declaration. And similar to before, we can rely on newRange being exactly like range except for low - there can be no hidden state that we failed to transport. And the language really doesn&#39;t have to do much here:</p>
<ul>
<li>declare variables for components (e.g. low, high) and assign values via accessors</li>
<li>execute the with block</li>
<li>pass the variables to the canonical constructor</li>
</ul>
<p>(Note that this feature is far from being a reality and might get dropped or change considerably.)</p>
<h3 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h3><p>To turn an instance into a byte stream, a JSON or XML document, or any other external representation and back again requires a way to take an instance apart into its values and then take those values and put them back together. You can immediately see how this works really well with records. Not only do they expose all their state and offer a canonical constructor, they do so in a structured way that makes the reflection API for that very straightforward to use.</p>
<p>For a lot more about how records changed serialization, check out <a target="_blank" rel="noopener" href="https://inside.java/2021/03/08/podcast-014/">the Inside Java Podcast, episode 14</a> (also on many audio platforms, e.g. on <a target="_blank" rel="noopener" href="https://open.spotify.com/episode/6lmaaDwvV7NaJ3YFrid3ww">Spotify</a>). If you prefer a short read, I wrote <a target="_blank" rel="noopener" href="https://twitter.com/nipafx/status/1371093883631833092">a Twitter thread</a> about it.</p>
<h3 id="Also-The-Boilerplate"><a href="#Also-The-Boilerplate" class="headerlink" title="Also, The Boilerplate"></a>Also, The Boilerplate</h3><p>Going back to the boilerplate for a second. As explained earlier, we need the following code so a record can be a product type:</p>
<ul>
<li>canonical constructor</li>
<li>accessors</li>
<li>no inheritance</li>
</ul>
<p>I didn&#39;t explicitly state that, but it&#39;s kinda nice if (0, 0) &#x3D; (0, 0), so a proper equals implementation is welcome as well, which immediately requires a hashCode implementation.</p>
<p>Since we need all that, the compiler might as well generate it. So it does (and throws in toString for good measure) - not so much to save us from writing it but because it&#39;s a natural consequence of the algebraic structure.</p>
<h2 id="Why-Records-Are-Worse"><a href="#Why-Records-Are-Worse" class="headerlink" title="Why Records Are Worse*"></a>Why Records Are Worse*</h2><p>Records&#39; semantics restrict which class-building tools you can use. As discussed, you can&#39;t add hidden state via additional fields, can&#39;t rename accessors, can&#39;t change their return type, and probably shouldn&#39;t change their return value. Records also don&#39;t allow reassigning component values, i.e. their backing fields are <strong>final</strong>, and no class inheritance (you can implement interfaces, though).</p>
<p>So what if you need that? Then records aren&#39;t what you&#39;re looking for and you need to create a regular class instead. Even if that means that just to change 10% of the functionality, you&#39;ll end up with 90% of the boilerplate that a record would&#39;ve prevented.</p>
<h3 id="Why-Lombok-39-s-Data-x2F-Value-Is-Better"><a href="#Why-Lombok-39-s-Data-x2F-Value-Is-Better" class="headerlink" title="Why Lombok&#39;s @Data&#x2F;@Value Is Better*"></a>Why Lombok&#39;s @Data&#x2F;@Value Is Better*</h3><p>Lombok just generates code. There&#39;s no semantic attached, so you have all the freedom you need to adapt the class to your requirements. Of course you don&#39;t get the benefits that come from stronger guarantees either, although Lombok may be able to generate destructuring methods in the future.</p>
<p><em>[Lombok attaches no semantics]</em></p>
<p>(That said, I don&#39;t advertise using Lombok. It heavily relies on APIs internal to the compiler, which can change at any time and which means projects using it can break on any minor Java update. That it goes to great lengths to hide that technical debt from its users isn&#39;t great either.)</p>
<h3 id="Why-Kotlin-39-s-Data-Classes-Are-Better"><a href="#Why-Kotlin-39-s-Data-Classes-Are-Better" class="headerlink" title="Why Kotlin&#39;s Data Classes Are Better*"></a>Why Kotlin&#39;s Data Classes Are Better*</h3><p>Here&#39;s what the docs say about data classes:</p>
<blockquote>
<p>You often create classes whose main purpose is to hold data. In such classes, some standard functionality and utility functions are often mechanically derivable from the data.</p>
</blockquote>
<p>You can see that the semantic of holding data is there as well, but it&#39;s pretty weak and the focus is on deriving functionality, i.e. generating code. Indeed, data classes offer more class building tools than records (mutable &quot;components&quot;, hidden state, ...), but unlike with Lombok, you can&#39;t use all of them (can&#39;t be extended, can&#39;t create your own copy method, ...). On the other hand, data classes don&#39;t give records&#39; strong guarantees, so Kotlin can&#39;t quite build the same features on top of them.</p>
<p><em>[Data classes have weak semantics]</em></p>
<p>Before you get your keyboards out to write angry comments (which you can&#39;t because I didn&#39;t get around to have those yet - har har), this is no value judgement. It&#39;s a different trade-off with different costs and benefits and if Kotlin&#39;s make more sense to you, that&#39;s fine with me. Don&#39;t @ me (as the kids say).</p>
<p><em>[There&#39;s not much use in declaring JVM records in Kotlin]</em></p>
<p><strong>Note:</strong><br>Readers have been pointing out Kotlin&#39;s @JvmRecord, some as a big gotcha: &quot;See, data classes can be records, too - check mate&quot; (I&#39;m paraphrasing but only barely). If you had the same thought, I ask you to stop and mull it over for a second. What exactly does that get you?</p>
<p>The data class has to abide by all record rules, which means it can&#39;t do more than records. But Kotlin still doesn&#39;t understand the concept of transparent tuples and can&#39;t do more with a <strong>@JvmRecord data class</strong> than with a regular data class. So you have records&#39; freedoms and data classes&#39; guarantees - the worst of both worlds.</p>
<p>Why does @JvmRecord exist, then? Just interoperability. As the proposal says:</p>
<blockquote>
<p>There&#39;s not much use in declaring JVM records in Kotlin besides two use cases:</p>
<ul>
<li>migrating an existing Java record to Kotlin and preserving its ABI;</li>
<li>generating a record class attribute with record component info for a Kotlin class to be read later by a potential framework relying on Java reflection to introspect records.</li>
</ul>
</blockquote>
<h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><ul>
<li>👇🏾</li>
</ul>
<p>So of course records aren&#39;t generally better or worse than the other two features or others with similar design like Scala&#39;s case classes. But they do have strong semantics with a firm mathematical foundation that, while limiting our class design space, enable powerful features that would otherwise not be possible or at least not as reliable.</p>
<p>It&#39;s a trade-off between developer freedom and language power. And it&#39;s one I&#39;m happy with and look forward to see unfolding it&#39;s full potential over the next years.</p>

  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>
    

    <a href="#top" class="top">返回顶部</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    zguishen
  </span>
   / Documentation licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
  </span>
</footer>
    </div>
  </body>
</html>